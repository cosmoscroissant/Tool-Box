import re
import sys
import argparse
import json
from pathlib import Path
from typing import List, Dict, Set, Optional
from datetime import datetime


class IoCScanner:    
    IOC_CATEGORY_ORDER = [
        'protocols_full',
        'urls',
        'domains',
        'files',
        'main_patterns',
        'ssh_patterns',
        'openssh_full',
        'operational_files',
        'dependency_paths'
    ]
    
    CATEGORY_NAMES = {
        'protocols_full': 'Protocol URLs',
        'urls': 'URLs',
        'domains': 'Domains',
        'files': 'Files',
        'main_patterns': 'Main Functions/Variables',
        'ssh_patterns': 'SSH Client References',
        'openssh_full': 'OpenSSH Full References',
        'operational_files': 'Operational Files',
        'dependency_paths': 'Dependency/Library Paths'
    }
    
    def __init__(self):
        self._initialize_patterns()
        
    def _initialize_patterns(self):
        self.ioc_patterns = {
            'protocols_full': re.compile(
                r'(?:https?|ftp|socks[45]?|ssh)://[a-zA-Z0-9.-]+(?::[0-9]+)?(?:/[^\s"\'<>]*)?',
                re.IGNORECASE
            ),
            'urls': re.compile(
                r'\b(?:https?|ftp|socks[45]?)://[^\s"\'<>]{10,}',
                re.IGNORECASE
            ),
            'domains': re.compile(
                r'\b[a-zA-Z0-9.-]+\.(?:tk|ml|ga|cf|top|click|download|security|update|onion|com|net|org|io|dev|ai|xyz)\b',
                re.IGNORECASE
            ),
            'files': re.compile(
                r'\b[a-zA-Z0-9_.-]+\.(?:exe|dll|scr|bat|cmd|pif|com|vbs|js|jar|zip|rar|7z|php|ps1|sh)\b',
                re.IGNORECASE
            ),
            'main_patterns': re.compile(
                r'\b(?:main\.[a-zA-Z0-9_]+|main_[a-zA-Z0-9_]+|_main[a-zA-Z0-9_]*)\b',
                re.IGNORECASE
            ),
            'ssh_patterns': re.compile(
                r'\b[a-zA-Z0-9_]*SSH(?:Client|Connection|Session)[a-zA-Z0-9_]*\b',
                re.IGNORECASE
            ),
            'openssh_full': re.compile(
                r'\b[a-zA-Z0-9._-]+@openssh\.com\b',
                re.IGNORECASE
            )
        }
        
        self.ida_patterns = {
            'sha256': re.compile(r';\s*Input SHA256\s*:\s*([A-Fa-f0-9]{64})', re.IGNORECASE),
            'md5': re.compile(r';\s*Input MD5\s*:\s*([A-Fa-f0-9]{32})', re.IGNORECASE),
            'crc32': re.compile(r';\s*Input CRC32\s*:\s*([A-Fa-f0-9]{8})', re.IGNORECASE)
        }
        
        # single comprehensive exclusion pattern
        self.ida_exclude_pattern = re.compile(
            r';\s*(?:\+\-+\+|\|\s*(?:This file was generated by|Copyright|License info).*|Input (?:SHA256|MD5|CRC32)\s*:|File Name\s*:|(?:Compiler|Format|Imagebase)\s*:)',
            re.IGNORECASE
        )
        
        self.windows_path_patterns = [
            re.compile(r'["\']([A-Za-z]:[/\\][^"\']*[/\\][^"/\'\\]*(?:\.[a-zA-Z0-9]{2,4})?)["\']', re.IGNORECASE),
            re.compile(r'\b([A-Za-z]:[/\\][a-zA-Z0-9_\.\-/\\]+\.[a-zA-Z0-9]{2,4})\b', re.IGNORECASE),
            re.compile(r'["\']([/\\][/\\][a-zA-Z0-9.-]+[/\\][^"\'\\]+[/\\][^"\']*)["\']', re.IGNORECASE),
            re.compile(r'["\']?(HKEY_[A-Z_]+[/\\][^"\'\\s]+)["\']?', re.IGNORECASE)
        ]
        
        self.string_pattern = re.compile(r'(?:db\s+)?["\']([^"\']{5,200})["\']', re.IGNORECASE)
        
        self.path_validation = {
            'go_module': re.compile(r'[/\\]pkg[/\\]mod[/\\].*(?:@v\d+\.\d+\.\d+|\.org[/\\]x[/\\]|@[^/\\]*[/\\])', re.IGNORECASE),
            'suspicious_path': re.compile(r'(?:[/\\](?:work|project|src|source|code|build|bin|cmd|command)[/\\]|[/\\](?:main|app|tool|util|client|server)\.[a-z]+$|^[A-Za-z]:[/\\](?:work|project|src|code|build|bin)[/\\])', re.IGNORECASE),
            'dependency': re.compile(r'(?:go[/\\]pkg[/\\]|[/\\]program files(?:\s\(x86\))?[/\\])', re.IGNORECASE)
        }
        
    def extract_ida_metadata(self, content: str) -> Dict:
        metadata = {}
        file_hashes = {}
        
        for key, pattern in self.ida_patterns.items():
            match = pattern.search(content)
            if match:
                file_hashes[key] = match.group(1).strip().lower()
                    
        if file_hashes:
            metadata['file_hashes'] = file_hashes
            
        return metadata
    
    def clean_content(self, content: str) -> str:
        return '\n'.join(line for line in content.split('\n') if not self.ida_exclude_pattern.match(line))
    
    def extract_strings(self, content: str) -> List[str]:
        bad_patterns = {'...', '%s', '%a', '%d', '%c'}
        return [match.strip() for match in self.string_pattern.findall(content) if not any(bad in match for bad in bad_patterns)]
    
    def extract_windows_paths(self, content: str) -> Dict[str, Set[str]]:
        dependency_paths = set()
        operational_files = set()
        
        for pattern in self.windows_path_patterns:
            for match in pattern.findall(content):
                cleaned_path = match.strip().strip('"\'')
                
                if self.is_valid_windows_path(cleaned_path):
                    if self.path_validation['dependency'].search(cleaned_path.lower()):
                        dependency_paths.add(cleaned_path)
                    else:
                        operational_files.add(cleaned_path)
                    
        return {'dependency_paths': dependency_paths,'operational_files': operational_files}
    
    def is_valid_windows_path(self, path: str) -> bool:
        if (len(path) < 6 or 
            any(pattern in path for pattern in ['%s', '%d', '%c', '%x', '%y', ':%', '@%']) or
            self.path_validation['go_module'].search(path)):
            return False
            
        if self.path_validation['suspicious_path'].search(path):
            return True
            
        return (path.startswith(('\\\\', '//')) or 
                (len(path) > 4 and path[1:3] == ':[/\\]' and 
                 (path.count('\\') >= 2 or path.count('/') >= 2)) or
                path.upper().startswith('HKEY_'))
    
    def is_valid_ioc(self, text: str, category: str) -> bool:
        if (len(text) < 3 or 
            any(text.endswith(bad) for bad in ['...', '%s', '%a', '%d', '@"', "@'", '"', "'"]) or
            '...' in text):
            return False
            
        if category == 'protocols_full':
            return (text.startswith(('http://', 'https://', 'ftp://', 'socks4://', 'socks5://', 'ssh://')) and not any(x in text for x in ['%s', '%a', '%d']))
        elif category == 'openssh_full':
            return '@openssh.com' in text.lower()
        elif category == 'files':
            return not text.startswith('.') and '.' in text and len(text.split('.', 1)[0]) > 0
            
        return True
    
    def scan_content(self, content: str, filename: str) -> Optional[Dict]:
        try:
            result = {'file': filename}
            
            ida_metadata = self.extract_ida_metadata(content)
            if ida_metadata:
                result.update(ida_metadata)
            
            cleaned_content = self.clean_content(content)
            strings = self.extract_strings(cleaned_content)
            full_content = f"{cleaned_content}\n{chr(10).join(strings)}"
            
            all_found_iocs = {}
            
            windows_paths = self.extract_windows_paths(full_content)
            for path_type, paths in windows_paths.items():
                if paths:
                    all_found_iocs[path_type] = sorted(paths)
                    
            for category, pattern in self.ioc_patterns.items():
                matches = set()
                for match in pattern.finditer(full_content):
                    text = match.group().strip().strip('"\'')
                    if self.is_valid_ioc(text, category):
                        matches.add(text)
                        
                if matches:
                    all_found_iocs[category] = sorted(matches)
            
            if all_found_iocs:
                result['iocs'] = {category: all_found_iocs[category] 
                                for category in self.IOC_CATEGORY_ORDER 
                                if category in all_found_iocs}
            
            return result if len(result) > 1 else None
            
        except Exception as e:
            return {'file': filename, 'error': str(e)}
    
    def scan_file(self, filepath: Path) -> Optional[Dict]:
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            return self.scan_content(content, str(filepath))
        except Exception as e:
            return {'file': str(filepath), 'error': str(e)}
    
    def scan_directory(self, directory: Path, recursive: bool = True) -> List[Dict]:
        pattern = "**/*.asm" if recursive else "*.asm"
        files = list(directory.glob(pattern))
        
        if not files:
            print(f"no .asm files found in {directory}")
            return []
            
        print(f"scanning {len(files)} files...")
        results = []
        
        for i, filepath in enumerate(files, 1):
            if i % 25 == 0:
                print(f"Progress: {i}/{len(files)} files processed")
                
            result = self.scan_file(filepath)
            if result:
                results.append(result)
                
        return results
    
    def generate_report(self, results: List[Dict], format_type: str = 'text') -> str:
        if format_type == 'json':
            return json.dumps(results, indent=2)
        
        total_files = len(results)
        files_with_iocs = sum(1 for r in results if r.get('iocs'))
        files_with_hashes = sum(1 for r in results if r.get('file_hashes'))
        files_with_errors = sum(1 for r in results if r.get('error'))
        
        category_counts = {}
        for result in results:
            if result.get('iocs'):
                for category, iocs in result['iocs'].items():
                    category_counts[category] = category_counts.get(category, 0) + len(iocs)
        
        report = [
            "=" * 80,
            f"Sniffer Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "=" * 80,
            "",
            "SUMMARY",
            "-" * 40,
            f"Total files processed: {total_files}",
            f"Files with IoCs: {files_with_iocs}",
            f"Files with Hashes: {files_with_hashes}",
            f"Files with Errors: {files_with_errors}",
            ""
        ]
        
        if category_counts:
            report.extend(["IoC CATEGORIES","-" * 40])
            for category in self.IOC_CATEGORY_ORDER:
                if category in category_counts:
                    name = self.CATEGORY_NAMES[category]
                    count = category_counts[category]
                    report.append(f"{name}: {count}")
            report.append("")
        
        report.extend(["DETAILED RESULTS", "=" * 80])
        
        for result in results:
            if result.get('error'):
                report.extend([f"ERROR - {result['file']}",f"  Error: {result['error']}",""])
                continue
                
            report.extend([f"File: {result['file']}","-" * 60])
                
            if result.get('file_hashes'):
                report.append("File Hashes:")
                for hash_type, hash_value in result['file_hashes'].items():
                    report.append(f"{hash_type.upper()}: {hash_value}")
                report.append("")
                
            if result.get('iocs'):
                for category in self.IOC_CATEGORY_ORDER:
                    if category in result['iocs']:
                        category_name = self.CATEGORY_NAMES[category]
                        report.append(f"{category_name}:")
                        for ioc in result['iocs'][category]:
                            report.append(f"{ioc}")
                        report.append("")
            
            report.append("")
            
        return '\n'.join(report)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('path', help='path to .asm file or directory')
    parser.add_argument('-r', '--recursive', action='store_true', help='scan recursively')
    parser.add_argument('-o', '--output', help='output file path')
    parser.add_argument('-f', '--format', choices=['json', 'text'], default='text',help='output format (default: text)')
    
    args = parser.parse_args()
    
    path = Path(args.path)
    if not path.exists():
        print(f"Error: Path '{args.path}' does not exist", file=sys.stderr)
        sys.exit(1)
    
    scanner = IoCScanner()
    
    if path.is_file():
        if path.suffix.lower() != '.asm':
            print(f"Error: '{args.path}' is not a .asm file", file=sys.stderr)
            sys.exit(1)
        result = scanner.scan_file(path)
        results = [result] if result else []
    elif path.is_dir():
        results = scanner.scan_directory(path, args.recursive)
    else:
        print(f"Error: '{args.path}' is not a file or directory", file=sys.stderr)
        sys.exit(1)
    
    if not results:
        print("no IoCs found in the scanned files")
        return
    
    report = scanner.generate_report(results, args.format)
    
    if args.output:
        try:
            with open(args.output, 'w', encoding='utf-8') as f:
                f.write(report)
            print(f"report saved to: {args.output}")
        except Exception as e:
            print(f"error writing to {args.output}: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        print(report)


if __name__ == "__main__":
    main()